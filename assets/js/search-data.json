{
  
    
        "post0": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote [^1]. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | .",
            "url": "https://roberttorfason.github.io/blog/markdown/2021/09/22/test-markdown-post.html",
            "relUrl": "/markdown/2021/09/22/test-markdown-post.html",
            "date": " • Sep 22, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Kosningaprof",
            "content": "Introduction . The Icelandic parliament election is on the 25. September. Before every election, media outlets set up a quiz/questionnaire where candidates get statements such as &quot;Iceland should be a part of NATO&quot; and &quot;The Icelandic government should put more money into the healthcare system&quot; and the candidates answer if they agree/disagree with or are neutral towards the statement. Users can then answer the same questions and figure out which candidates and political parties they are &quot;closest to&quot; their political beliefs using the answers to the questions. . These are mostly for fun and should only serve as an indicator, but it&#39;s an enjoyable process to go through and it&#39;s always interesting to see which candidates are &quot;most similar&quot; to oneself. . As a whole this collection of data, candidates and their answers to a set of questions, is interesting and has a lot of opportunities for some data exploration and the purpose of this post is to take the data from the RUV quiz explore it and try to answer some questions about it. . Similar (and definitely more rigorous) analysis has been done before by people designing the tests and actualluy working with the data, see for example this great thread here on this quiz. Since this should not be taken too seriously, the analysis in this post will be more about generating plausible hypthes and doing some ad-hoc analysis. . The Data . If you want to have the data for yourself, e.g. to run this notebook locally follow the instructions here to set up an environment and fetch the data. . Let&#39;s load the data, pre-process it and set up some helper objects . df_results, df_questions = pd.read_csv(&quot;results_2021.csv&quot;), pd.read_csv(&quot;questions_2021.csv&quot;) . # Pre-processing df_results[&quot;party&quot;] = df_results[&quot;party&quot;].astype(&quot;category&quot;) df_results[&quot;gender&quot;] = df_results[&quot;gender&quot;].astype(&quot;category&quot;) # Bin the ages. `pd.cut` returns intervals that are annoying to work with so we just use the # left age of each bin e.g. 30 to represent the interval [30, 40) age_binned_series = pd.cut(df_results[&quot;age&quot;], bins=[-10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100], right=False) df_results.insert(df_results.columns.get_loc(&quot;age&quot;) + 1, &quot;age_binned&quot;, age_binned_series) df_results[&quot;age_binned&quot;] = df_results[&quot;age_binned&quot;].map(lambda x: x.left).astype(int) # Most of the analysis centers around the political party so we drop the candiadates that don&#39;t have # a party specified df_results = df_results[~df_results[&quot;party&quot;].isna()] . . cols_questions = [c for c in df_results.columns if c.startswith(&quot;question_&quot;)] cols_meta = [c for c in df_results.columns if c not in cols_questions] question_id_to_string = dict(zip(df_questions[&quot;question_number&quot;], df_questions[&quot;question&quot;])) . . and take a look at the structure . df_questions.head(3) . question_number id question . 0 question_0 | 5719843612393472 | Íslenskt samfélag einkennist af réttlæti, sann... | . 1 question_1 | 5692341510733824 | Það á að leyfa kórónuveirunni að ganga án sótt... | . 2 question_2 | 5284747587616768 | Stjórnvöld eiga að setja strangar takmarkanir ... | . df_questions has all the questions and their ids/numbers. . df_results.head(3) . name party age age_binned gender timestamp constituency answering_done timestamp_dt question_0 ... question_21 question_22 question_23 question_24 question_25 question_26 question_27 question_28 question_29 question_30 . 0 Elín Tryggvadóttir | Samfylkingin | 46 | 40 | Kona | 1631051439022 | Reykjavíkurkjördæmi suður | 1.0 | 2021-09-07 21:50:39.022 | 51 | ... | 83 | 3 | 100 | 93 | 100 | 100 | 100 | 8 | 100 | 63 | . 1 Ágústa Anna Ómarsdóttir | Sósíalistaflokkurinn | 55 | 50 | Kona | 1631547337578 | Norðvesturkjördæmi | 1.0 | 2021-09-13 15:35:37.578 | 0 | ... | 0 | 27 | 61 | 61 | 96 | 100 | 100 | 0 | 100 | 32 | . 2 María Lilja Þrastardóttir Kemp | Sósíalistaflokkurinn | 35 | 30 | Kona | 1631030960104 | Reykjavíkurkjördæmi suður | 1.0 | 2021-09-07 16:09:20.104 | 22 | ... | 100 | 2 | 100 | 58 | 100 | 100 | 100 | 38 | 100 | 24 | . 3 rows × 40 columns . df_results represents each candidate in a row, metadata (age, party, name) and the results for all the questions, where each answer is on the scale from 0-100. . &quot;&quot;&quot; This text is in a code cell because it&#39;s not possible to collapse markdown cells in fastpages Additionally each question in `df_results` has a mapping back to `df_questions` via the column name. Note that the way the questions are indexed there is an easy correspondance between the (numeric) index of each column and `df_questions`. This means that when we later transform the data to numpy arrays, where we don&#39;t have named columns, and do something like `x[:, 3]`, it will correspond to `df_questions.iloc[3]` so going back and forth between the data and the actual questions is easy. &quot;&quot;&quot;; . . Interactive Histogram of Questions and Answers . Below we visualize a histogram of the questions where you can select individual parties and select the questions to see the difference. The questions are ordered by how &quot;interesting&quot; they are, where the standard deviation of each question is used as a proxy for how interesting it is. If everyone answers the same, the std. will be low. If everyone answers different it will be medium and if there is a strong split where candidates either agree or disagree with the statements . df_results_melt = pd.melt(df_results, id_vars=cols_meta, value_vars=cols_questions) df_results_melt = df_results_melt[[&quot;party&quot;, &quot;variable&quot;, &quot;value&quot;]] df_results_melt = df_results_melt.rename(columns={&quot;variable&quot;: &quot;question&quot;, &quot;value&quot;: &quot;Answer Value&quot;}) df_results_melt[&quot;question&quot;] = df_results_melt[&quot;question&quot;].replace(question_id_to_string) df_results_melt[&quot;question&quot;] = df_results_melt[&quot;question&quot;].astype(&quot;category&quot;) . . df_questions_std = df_results_melt.groupby(&quot;question&quot;).std().sort_values(&quot;Answer Value&quot;, ascending=False) questions_sorted = df_questions_std.index.to_list() . df_results_melt.groupby([&quot;party&quot;, &quot;question&quot;]).std().groupby(&quot;party&quot;).mean().sort_values(&quot;Answer Value&quot;, ascending=False).reset_index() . party Answer Value . 0 Miðflokkurinn | 28.339318 | . 1 Sjálfstæðisflokkurinn | 23.921914 | . 2 Frjálslyndi Lýðræðisflokkurinn | 23.890085 | . 3 Framsóknarflokkurinn | 21.140510 | . 4 Viðreisn | 20.839005 | . 5 Flokkur Fólksins | 20.393239 | . 6 Vinstri Græn | 19.294324 | . 7 Píratar | 18.837223 | . 8 Sósíalistaflokkurinn | 18.455783 | . 9 Samfylkingin | 16.492775 | . 10 Ábyrg Framtíð | NaN | . Dimensionality reduction and embeddings . from sklearn.decomposition import PCA, NMF . Let&#39;s pick out only the questions and transform the extracted questions to a numpy array to be used with sklearn and normalize them to be in the range [0, 1] . df_questions_only = df_results.filter(like=&quot;question_&quot;) x = df_questions_only.to_numpy() x = x.astype(float) / 100 x.shape . (311, 31) . pca = PCA(n_components=10) x_pca = pca.fit_transform(x) . clf = PCA(n_components=10) y_val = &quot;party&quot; x_pca_questions = clf.fit_transform(x.T) x_pca_questions.shape clf.components_[0] # Sum over parties for i, val in enumerate(df_users[y_val].cat.categories): print(val) print(np.sum(clf.components_[1][df_users[&quot;party&quot;].cat.codes.to_numpy() == i])) . df_pca_q = pd.DataFrame(x_pca_questions) df_pca_q.columns = df_pca_q.columns.astype(str) df_pca_q = pd.concat([df_questions, df_pca_q], axis=1) df_pca_q.head(5) . Plot the questions (interactive dropdown) . alt.Chart(df_pca_q).mark_circle(size=60).encode( x=&#39;0&#39;, y=&#39;1&#39;, #color=&#39;party&#39;, tooltip=[&#39;question&#39;] ).interactive() . #plt.figure() #plt.plot(clf.components_[0]) #plt.plot(clf.components_[1]) #plt.plot(clf.components_[2]) #plt.plot(clf.components_[3]) . df_pca = pd.DataFrame(x_pca) df_pca.columns = df_pca.columns.astype(str) df_pca = pd.concat([df_users[cols_meta], df_pca], axis=1) df_pca = df_pca.drop(columns=[&quot;age_binned&quot;]) df_pca.head(5) . alt.Chart(df_pca).mark_circle(size=60).encode( x=&#39;0&#39;, y=&#39;1&#39;, color=&#39;party&#39;, tooltip=[&#39;party&#39;, &quot;name&quot;] ).interactive() . df_users[&quot;party&quot;].cat.categories . df_users[&quot;party&quot;].head(), df_users[&quot;party&quot;].cat.codes.head() . model = NMF(n_components=2, init=&#39;random&#39;, max_iter=400, alpha=0.5, l1_ratio=0.5) W = model.fit_transform(x) H = model.components_ np.mean(np.abs(W @ H - x)) # What users/questions is it hard to reconstruct? . df_users[&quot;age_binned&quot;] = pd.cut(df_users[&quot;age&quot;], bins=[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) . df_users[&quot;age_binned&quot;].cat.codes # needs gradual color scheme i.e. old is dark and young is a lighter shade of the same color . y_val = &quot;party&quot; y = df_users[y_val].cat.codes.to_numpy() plt.figure(figsize=(12, 12)) for i, val in enumerate(df_users[y_val].cat.categories): plt.scatter(W[y == i, 0], W[y == i, 1], label=val) plt.legend() . Classification to find the &quot;most important&quot; questions | Biggest outlier per party | Do any later components in PCA explain something else than party? E.g. age? | . # I think the orthogonal direction means: Which questions do most people agree on plt.figure(figsize=(15, 15)) for i in list(range(len(H.T)))[:10]: plt.scatter(H.T[i, 0], H.T[i, 1], label=df_questions[&quot;question&quot;].iloc[i]) plt.legend() # Áhugavert, Alþjóðaás vs. þjóðernisás? Heilbrigðisþjónusta í cluster . import altair as alt . . import altair as alt #from vega_datasets import data #source = data.cars() #source = pd.DataFrame({&quot;Component0&quot;: H.T[:, 0], &quot;Component1&quot;: H.T[:, 1]}) source = pd.DataFrame({&quot;Component0&quot;: W[:, 0], &quot;Component1&quot;: W[:, 1], &quot;party&quot;: df_users[&quot;party&quot;], &quot;name&quot;: df_users[&quot;name&quot;]}) alt.Chart(source).mark_circle(size=60).encode( x=&#39;Component0&#39;, y=&#39;Component1&#39;, color=&#39;party&#39;, tooltip=[&#39;party&#39;, &quot;name&quot;] ).interactive() . import altair as alt from vega_datasets import data # Passa að df_questions passi örugglega við H source = data.cars() source = pd.DataFrame({&quot;Component0&quot;: H.T[:, 0], &quot;Component1&quot;: H.T[:, 1], &quot;question&quot;: df_questions[&quot;question&quot;], &quot;num&quot;: range(len(H.T[:, 0]))}) alt.Chart(source).mark_circle(size=60).encode( x=&#39;Component0&#39;, y=&#39;Component1&#39;, #color=&#39;party&#39;, tooltip=[&#39;question&#39;, &#39;num&#39;] ).interactive() . There is a constant that can be moved arbitrarily between the matrices. How about scaling users in [0, 1] and setting questions to [0, 100]? . from sklearn.decomposition import FastICA transformer = FastICA(n_components=2) x_ica = transformer.fit_transform(x) . x_ica.shape . transformer.components_ . import altair as alt from vega_datasets import data # Passa að df_questions passi örugglega við H source = data.cars() source = pd.DataFrame({&quot;Component0&quot;: x_ica[:, 0], &quot;Component1&quot;: x_ica[:, 1], &quot;name&quot;: df_users[&quot;name&quot;], &quot;party&quot;: df_users[&quot;party&quot;]}) alt.Chart(source).mark_circle(size=60).encode( x=&#39;Component0&#39;, y=&#39;Component1&#39;, color=&#39;party&#39;, tooltip=[&#39;name&#39;] ).interactive() . . Fill in NaNs using KNN. k closest users, take the mean and use that to fill in Matrix factorization is also interesting. Feature vector for questions not that interesting? Dno, probably also possible to calculate using correlation or implicit from the results of the PCA . Hvaða spurning hefur mest predictive value fyrir . Aldur | Flokk | Kyn | . Vitum a-priori hvað targettin eru, hvaða clustering aðferð er best? . Mean median of a question! . Density of points to see conformity? How? Variance? Something else? Mean distance of everyone to everyone? . Compare ranking based on metrics: Cosine, correlation, l2, l1 . df_users.party.unique() . df_users_filter = df_users[~df_users[&quot;party&quot;].isna()] df_users_filter = df_users_filter[df_users_filter[&quot;party&quot;] != &quot;Ábyrg Framtíð&quot;] print(df_users_filter.party.cat.categories) x = df_users_filter.filter(like=&quot;question_&quot;).to_numpy() x = x.astype(float) / 100 # Try gender y = df_users_filter[&quot;party&quot;].cat.codes.to_numpy() x.shape, y.shape . from sklearn.ensemble import RandomForestClassifier clf = RandomForestClassifier() . from sklearn.model_selection import cross_validate cv_results = cross_validate(clf, x, y, cv=5) cv_results . from sklearn.model_selection import KFold kf = KFold(n_splits=3, random_state=None, shuffle=True) train_index, test_index = next(kf.split(x)) clf.fit(x[train_index, :], y[train_index]) from sklearn.metrics import plot_confusion_matrix plot_confusion_matrix(clf, x[test_index, :], y[test_index], display_labels=df_users_filter[&quot;party&quot;].cat.categories.to_list()[:-1]) len(test_index), len(train_index), df_users_filter[&quot;party&quot;].cat.categories # Who is confused? . np.unique(y[test_index], return_counts=True) . df_users[&quot;party&quot;].isna().sum() clf.feature_importances_ . df_questions.iloc[7] . Feature selection . from sklearn.feature_selection import f_classif, SelectKBest, chi2, mutual_info_classif . chi2(x, y) . top_vals = mutual_info_classif(x, y) . idx_sort = np.argsort(top_vals)[::-1] . df_questions.iloc[idx_sort,:][&quot;question&quot;].to_list() . from sklearn.metrics import pairwise_distances dist_mat = pairwise_distances(x, metric=&quot;cosine&quot;) dist_mat for m in [&quot;cosine&quot;, &quot;l2&quot;, &quot;l1&quot;]: dist_mat = pairwise_distances(x[100:101, :], x, metric=m).ravel() idx_sort = np.argsort(dist_mat) print(m) print(idx_sort[:10]) print(dist_mat[idx_sort[:10]]) plt.figure() plt.plot(x[100]) plt.plot(x[25]) plt.plot(x[5]) dist_mat dist_mat = pairwise_distances(x, metric=&quot;cosine&quot;) dist_mat def _party_idx(): &quot;&quot;&quot;Maps the name of the party to indices&quot;&quot;&quot; ... for i, val in enumerate(df_users_filter[&quot;party&quot;].cat.categories): dist_mat_party = dist_mat[y == i, :][:, y == i] print(val) print(np.mean(dist_mat_party)) dist_mat_party += np.diag(10000 * np.ones(dist_mat_party.shape[0])) np.argmax(np.min(dist_mat_party, axis=0)) df_users_filter.loc[y == 5].iloc[28] . Thoughts . Skoða aldur, kyn, flokk sem target . Þetta eru ekki gögn í evklíðsku rúmi, nota KernelPCA með cosine eða jafnvel mutual information? Eða cross entropy . Motivating dæmi fyrir cosine, einn er hlédrægur og kýs alltaf nálægt miðjunni, annar lýs alltaf langt frá. Hlédrægi mun samt vera nær einhverjum sem er hlédrægur í hina stefnuna. Mælir meira hlédrægni vs. ákveðni? . Fill in NaNs using KNN. k closest users, take the mean and use that to fill in Matrix factorization is also interesting. Feature vector for questions not that interesting? Dno, probably also possible to calculate using correlation or implicit from the results of the PCA . Hvaða spurning hefur mest predictive value fyrir . Aldur | Flokk | Kyn | . Vitum a-priori hvað targettin eru, hvaða clustering aðferð er best? . df_results.isna().sum() . This adds a linked superscript 1 . 1. This is the actual footnote↩ .",
            "url": "https://roberttorfason.github.io/blog/election/data-science/machine-learning/2021/09/22/kosningaprof.html",
            "relUrl": "/election/data-science/machine-learning/2021/09/22/kosningaprof.html",
            "date": " • Sep 22, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://roberttorfason.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://roberttorfason.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}